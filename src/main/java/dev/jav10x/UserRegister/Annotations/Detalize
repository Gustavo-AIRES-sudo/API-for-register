---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
É importante destacar as anotações do Mapping:
    @GetMapping é responsável por puxar informações;
    @PostMapping é responsável por mandar informações;
    @PutMapping é responsável por alterar informações;
    @PatchMapping também é responsável por alterar informações;
    @DeleteMapping é responsável por deletar a informação;

    //TODO: Criar as informações do usuário: nome, sobrenome, idade e trabalho.
    //TO COMMIT SOMETHING: git commit -m "Rename"
    //TO SEE THE COMMITS IN THE PAST: git log --oneline
    //TO UPDATE ANY COMMIT, UPDATING SOME THINGS THAT YOU DON'T REALIZED: git commit --amend
    //TO FORCE THE PUSH: git push --force

    @Entity: Advinda da JPA, ela transforma toda a classe em uma entidade. Mapeia a classe em uma table;

    @Table: Alocação das variáveis em uma tabela;

    @Id: Demonstra ao provedor de persistência a necessidade desse valor ter uma forma única, que no caso, é a variável "ID".
    Isso é necessário para a referenciação de cada linha da tabela. Sem a anotação "@Id" não será possível manipular os dados do banco de dados

    @GeneratedValue: Gera um sequência de valores para o ID, que serve para a manipulação de dados do usuário;

    @ManyToOne: Usuário tem uma única resposanbilidade: muitos (nome da classe) terão uma responsabilidade.

    @OneToMany: Uma responsabilidade poderá ser aplicada à vários usuários.

    @JoinColumn: Cria uma Foreing Key / Chave Estrangeira. Essa foreing key tem função de conectar duas tabelas ou mais, de modo que essa foreing key seja direcionada à chave primeira, que geralmente é o ID.

    @Column (unique = true): Transforma a coluna de determinada tabela única, ou seja, essa coluna não poderá haver repetições de elementos;
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    "A JPA exige um contrato básico para que uma classe seja considerada uma Entidade Persistente válida:
     -> Deve ser anotada com @Entity.
     ->Deve ter um campo que represente a chave primária, anotado com @Id.

     Se o seu objeto Java não tiver um campo marcado com @Id, o framework não sabe como mapear o objeto para uma linha específica no banco de dados.

     Como o framework saberia qual linha buscar? Ele precisa do ID.
     Como o framework saberia qual linha atualizar? Ele precisa do ID.
     Como o framework saberia qual valor usar como chave estrangeira em outros relacionamentos? Ele precisa do ID.

     O Que Acontece sem o @Id?
        ->Erro de configuração de run time no início da aplicação"

        OTHER VISION

     JpaRepository: abstrador >> Simplifica ações a aplicação, especificamente no Repository, o qual armazenará informações no database. É necessário informar qual classe o ORM escaneará ativamente e o tipo do ID da classe, veja:
     JpaRepository<(nome da classe), (tipo do ID)> -> JpaRepository<UserModel, Long>
     ORM(Object Relational Mapping): verifica toda a classe que está sendo passada no JpaRepository na aplicação e cria uma tabela parecida com a a entidade(Entity). O ORM basicamente mapeia a classe e traduz para o banco de dados(conecta a POO com o banco de dados), armazenando os dados de forma que o database entenda, uma vez que tal tecnologia tenha uma linguagem de interpretação própria.
     ...Por exemplo, para um banco de dados, o meu long ID seria uma (PK)(primary key), o String userFullName e String userGmail seria um (VARCHAR(255))->(255 caractéres), o userAge seria um (INT) e responsabilities_id como FK(Foreing Key).
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    Lombok: Biblioteca java abstradora, ou seja, facilita certas tarefas como: criar Getters, Setters, Construtores, entre outros:
        @NoArgsConstructor(Lombok): Cria um construtor vazio(no-args-constructor --sem argumento--) parâmetros da aplicação;
        @AllArgsConstructor(Lombok): Cria todos os construtores com parâmetros(all-args-constructor) para a aplicação;
        @Data(Lombok): Cria Getters e Setters das variáveis;
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    -- INFORMAÇÕES IMPORTANTES --
        É DE SUMA IMPORTÂNCIA QUE A ANOTAÇÃO @OneToMany(MappedBy = "responsabilties") ESTEJA IGUAL A VARIÁVEL EM QUE SE DESEJA APLICAR A RELAÇÃO ENTRE VARIÁVEIS.
        ISTO É: SE DESEJO ESTABELECER UMA RELAÇÃO EM QUE UMA RESPOSABILIDADE PODERÁ SER APLICADA À VARIOS USUÁRIOS, ENTÃO O CAMPO DE DECLARAÇÃO APÓS "MAPPEDBY" DEVE SER IGUAL À VERIÁVEL QUE ESTAMOS ESTABELCENDO CONEXÃO COM O USUÁRIO(USER).
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    -- BANCO DE DADOS(H2) --

    JDBC - JAVA DATABASE CONNECTIVITY -- DEFINE COMO O CÓDIGO JAVA DEVE SE COMUNICAR COM QUALQUER BANCO DE DADOS.
    O JDBC FAZ QUATRO OPERAÇÕES BÁSICAS: C(CREATE) R(READ) U(UPDATE) D(DELETE)

    spring.h2.console.enabled=true -->ATIVA O BANCO DE DADOS
    spring.h2.console.path=/h2-console -->DEFINE O NOME LOCAL PARA ACESSAR O BANCO DE DADOS (localhost:(portal)/h2-console(você define o nome)
    spring.datasource.url=jdbc:h2:mem:userdb -->FAZ TRÊS COISAS: 1- DEFINE QUE É UM BANCO H2: "jdbc:h2:..." 2- DEFINE QUE ELE RODA NA MEMÓRIA: ""...:mem:..." 3- DEFINE O NOME DO BANCO DE DADOS: "...:userdb"
    spring.datasource.driverClassName=org.h2.Driver ->DEFINE A CLASSE DRIVER, OU SEJA, A QUE TRADUZ OS COMANDOS DO JAVA PARA A SQL DO H2
    spring.datasource.username=sa
    spring.datasource.password=